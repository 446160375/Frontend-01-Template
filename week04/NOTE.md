# 每周总结可以写在这里

### 事件循环
  * JS会创建一个类似于while(true)的循环，每执行一次循环体的过程称为Tick，每次Tick的过程就是查看是否有待处理事件，如果有则取出相关事件及回调函数放入执行栈中由主线程执行，待处理的事件会存储在一个任务队列中，也就是每次Tick都会查看任务队列中是否有需要执行的任务；实际上事件循环是指主线程重复从消息队列取出消息、执行的过程；

### 任务队列
 * 也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即异步操作的回调函数，异步操作会将相关回调添加到任务队列中，而不同的异步操作添加到任务队列的时机也不同，如onclick，setTimeout，ajax处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：
    * 1） onclick由浏览器内核的DOM Binding模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；
    * 2） setTimeout会由浏览器内核的timer模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；
    * 3） ajax会由浏览器内核的network模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中；

### 宏任务
  * 渲染事件（如解析 DOM、计算布局、绘制）；
  * 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
  * JavaScript 脚本执行事件；
  * 网络请求完成、文件读写完成事件。

### 微任务
异步回调的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

在现代浏览器里面，产生微任务有两种方式。

第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。

第二种方式是使用 Promise/async&await(async函数会隐式返回一个promise实例)，当调用 Promise.resolve() / Promise.reject() /await的时候，也会产生微任务。

通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。

* 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
* 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
* 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。
参考资料：李兵老师的《浏览器工作原理与实践》

## 相关知识点总结
* 其实所有的JS代码都是一个微任务，只是哪些微任务构成了一个宏任务；执行在JS引擎里的就是微任务，执行在JS引擎之外的就是宏任务，循环宏任务的工作就是事件循环。

* 事件循环不属于JavaScript引擎实现的东西，而是由浏览器或NodeJS宿主环境实现的

* 一个宏任务里的同步代码可以理解为微任务，只不过比宏任务里的异步代码的微任务优先入队。

* 微任务是没有优先级的，一个宏任务中只存在一个微任务队列，根据入队时间决定微任务顺序，列表里的所有微任务执行完才会执行下一个宏任务。

* Promise的then方法以及async函数里的await（await相当于语法上的then，then在分号之后）会将一个微任务入队，添加在微任务队列的最后。

  拿浏览器举例：setTimeout、setInterval 这种其实不是 JS 语法本身的 API，是 JS 的宿主浏览器提供的 API， 所以是宏任务。 而 Promise 是 JS 本身自带的 API，这种就是微任务。

总结：宿主提供的方法是宏任务，JS 自带的是微任务




